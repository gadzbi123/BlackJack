Microsoft (R) Macro Assembler Version 14.29.30037.0	    06/25/21 08:24:36
mydll.asm						     Page 1 - 1


				;-------------------------------------------------------------------------
				.386 
				.MODEL FLAT, STDCALL

				OPTION CASEMAP:NONE

				.NOLIST
				.LIST

 00000000			.data 
 00000000 41 47 49 4B 53	DataString DB 'AGIKSZJ', 0FFH	; definicja ciagu znakow  
	   5A 4A FF

 00000000			.code 

 00000000			DllEntry PROC hInstDLL:DWORD, reason:DWORD, reserved1:DWORD

 00000003  B8 00000001		    MOV EAX, 1;TRUE 
				    RET

 0000000C			DllEntry ENDP
mydll.asm(22) : warning A6004:procedure argument or local not referenced : hInstDLL
mydll.asm(22) : warning A6004:procedure argument or local not referenced : reason
mydll.asm(22) : warning A6004:procedure argument or local not referenced : reserved1

				;**************************************************************************** 
				;* Procedura FindChar_1 wyszukiwania znaku 'J' w ciagu 'DataString' * 
				;* * 
				;* Bezposrednia adresacja indeksowa * 
				;* Parametry wejsciowe: * 
				;*	AH - szukany znak 'J' * 
				;* Parametry wyjsciowe: * 
				;*	EAX - BOOL TRUE Found, FALSE not found * 
				;* * 
				;**************************************************************************** 
 0000000C			FindChar_1 PROC 
 0000000C  BE 00000000 R	    MOV ESI, OFFSET DataString	; zaladuj offset zmiennej 'DataString' do rej. ESI 
 00000011  B0 4A		    MOV AL, 'J'					; zaladuj kod litery 'J' do rej. AH 
 00000013			Check_End: 
 00000013  80 3E FF		    CMP BYTE PTR [ESI], 0FFH	; //ZMIENIONE Z 0FFFFH
 00000016  74 0D		    JE Not_Find					; znaleziono znak konca (wartownik) 
 00000018  3A 06		    CMP AL, [ESI]			; porownaj znak z elementem lancucha 'DataString' 
 0000001A  74 05		    JE Got_Equal				; znaleziono znak! 
 0000001C  83 C6 01		    ADD ESI, 1					; inkrementuj offset
 0000001F  EB F2		    JMP Check_End				; petla wyszukiwania 
 00000021			Got_Equal: 
 00000021  8A 16		    MOV DL, [ESI]				; zaladuj znaleziony znak do DL 
 00000023  EB 06		    JMP Done 
 00000025			Not_Find: 
 00000025  B8 00000000		    MOV EAX,0					; nie znaleziono znaku 
 0000002A  C3			    RET							; powrot z procedury 
 0000002B			Done: 
 0000002B  B8 00000001		    MOV EAX,1					; znaleziono znak 
 00000030  C3			    RET							; powrot z procedury 
 00000031			FindChar_1 ENDP					; koniec FindChar_1 

				;**************************************************************************** 
				;* Procedura FindChar_2 wyszukiwania znaku 'J' w ciagu 'LocalString' * 
				;* * 
				;* Bezposrednia adresacja indeksowa * 
				;* Parametry wejsciowe: * 
				;*	AH - szukany znak 'J' * 
				;* Parametry wyjsciowe: * 
				;*	EAX - BOOL TRUE Found, FALSE not found * 
				;* * 
				;**************************************************************************** 
 00000031 C3 47 49 4B 53	LocalString DB 0C3H,'GIKSZJ', 0FFH ; definicja ciagu znakow 
	   5A 4A FF
 00000039			FindChar_2 PROC 
 00000039  BE 00000031 R	    MOV ESI, OFFSET LocalString ; zaladuj offset zmiennej 'LocalString' do rej. ESI 
 0000003E  B4 4A		    MOV AH, 'J'					; zaladuj kod litery 'J' do rej. AH 
 00000040			Check_End: 
 00000040  80 3E FF		    CMP BYTE PTR [ESI], 0FFH	; czy koniec lancucha (znak specjalny FF)? 
 00000043  74 0D		    JE Not_Find				; znaleziono znak konca (wartownik) 
 00000045  3A 26		    CMP AH, [ESI]			; porownaj znak z elementem lancucha 'LocalString' 
 00000047  74 05		    JE Got_Equal				; znaleziono znak! 
 00000049  83 C6 01		    ADD ESI, 1					; inkrementuj offset 
 0000004C  EB F2		    JMP Check_End				; petla wyszukiwania 
 0000004E			Got_Equal: 
 0000004E  8A 16		    MOV DL, [ESI]				; zaladuj znaleziony znak do DL 
 00000050  EB 06		    JMP Done 
 00000052			Not_Find: 
 00000052  B8 00000000		    MOV EAX,0					; nie znaleziono znaku 
 00000057  C3			    RET							; powrot z procedury 
 00000058			Done: 
 00000058  B8 00000001		    MOV EAX,1					; znaleziono znak 
 0000005D  C3			    RET							; powrot z procedury 
 0000005E			FindChar_2 ENDP					; koniec FindChar_2 
				;**************************************************************************** 
				;* Procedura FindChar_3 wyszukiwania znaku 'J' w ciagu 'AppString' * 
				;* * 
				;* Bezposrednia adresacja indeksowa * 
				;* Parametry wejsciowe: * 
				;* AH - szukany znak 'J' * 
				;* Rej: ESI - offset adresu zmiennej 'AppString' * 
				;* Parametry wyjsciowe: * 
				;* EAX - BOOL TRUE Found, FALSE not found * 
				;* * 
				;**************************************************************************** 
 0000005E			FindChar_3 PROC AppString: DWORD 
 00000061  8B 75 08		    MOV ESI, AppString		; zaladuj offset zmiennej 'AppString' do rej. ESI 
 00000064  B4 4A		    MOV AH, 'J'					; zaladuj kod litery 'J' do rej. AH 
 00000066			Check_End: 
 00000066  80 3E FF		    CMP BYTE PTR [ESI], 0FFH	; czy koniec lancucha (znak specjalny FF)? 
 00000069  74 0D		    JE Not_Find					; znaleziono znak konca (wartownik) 
 0000006B  3A 26		    CMP AH, [ESI]			; porownaj znak z elementem lancucha 'AppString' 
 0000006D  74 05		    JE Got_Equal				; znaleziono znak! 
 0000006F  83 C6 01		    ADD ESI, 1					; inkrementuj offset 
 00000072  EB F2		    JMP Check_End				; petla wyszukiwania 
 00000074			Got_Equal: 
 00000074  8A 16		    MOV DL, [ESI]				; zaladuj znaleziony znak do DL 
 00000076  EB 09		    JMP Done 
 00000078			Not_Find: 
 00000078  B8 00000000		    MOV EAX,0					; nie znaleziono znaku 
				    RET							; powrot z procedury 
 00000081			Done: 
 00000081  B8 00000001		    MOV EAX,1	                ; znaleziono znak 
				    RET
 0000008A			FindChar_3 ENDP					; koniec FindChar_3 
				;**************************************************************************** 
				;* Procedura FindChar_4 wyszukiwania znaku 'J' w ciagu 'DataString' * 
				;* * 
				;* Bezposrednia adresacja indeksowa * 
				;* Parametry wejsciowe: * 
				;* Rej: ESI - indeks zmiennej 'DataString' * 
				;* AH - szukany znak 'J' * 
				;* Parametry wyjsciowe: * 
				;* EAX - BOOL TRUE Found, FALSE not found * 
				;* * 
				;**************************************************************************** 
 0000008A			FindChar_4 PROC NEAR			; deklaracja procedury FindChar_4 
 0000008A  BE 00000000		    MOV ESI, 0				; zaladuj indeks lancucha 'DataString' do ESI 
 0000008F  B4 4A		    MOV AH, 'J'					; zaladuj kod litery 'J' do rej. AH 
 00000091			Check_End: 
 00000091  80 BE 00000000 R	    CMP DataString[ESI], 0FFH	; czy koniec lancucha (znak specjalny FF)? 
	   FF
 00000098  74 16		    JE Not_Find					; znaleziono znak konca (wartownik) 
 0000009A  3A A6 00000000 R	    CMP AH, BYTE PTR DataString[ESI] ; porownaj znak z elementem lancucha 'DataString' 
 000000A0  74 06		    JE Got_Equal				; znaleziono znak! 
 000000A2  66| 83 C6 01		    ADD SI, 1					; inkrementuj indeks 
 000000A6  EB E9		    JMP Check_End				; petla wyszukiwania 
 000000A8			Got_Equal: 
 000000A8  8A 96 00000000 R	    MOV DL, DataString[ESI]		; zaladuj znaleziony znak do DL 
 000000AE  EB 06		    JMP Done 
 000000B0			Not_Find: 
 000000B0  B8 00000000		    MOV EAX,0					; nie znaleziono znaku 
 000000B5  C3			    RET							; powrot z procedury 
 000000B6			Done: 
 000000B6  B8 00000001		    MOV EAX,1					; znaleziono znak 
 000000BB  C3			    RET							; powrot z procedury 
 000000BC			FindChar_4 ENDP					; koniec FindChar_4 
				;**************************************************************************** 
				;* Procedura FindChar_5 wyszukiwania znaku 'J' w ciagu 'DataString' * 
				;* * 
				;* Adresacja Base + Index * 
				;* Parametry wejsciowe: * 
				;* Rej: BX - offset zmiennej 'DataString' * 
				;* Parametry wyjsciowe: * 
				;* EAX - BOOL TRUE Found, FALSE not found * 
				;* * 
				;**************************************************************************** 
 000000BC			FindChar_5 PROC NEAR 
 000000BC  BB 00000000 R	    MOV EBX, OFFSET DataString	; zaladuj offset zmiennej 'DataString' do rej. EBX 
 000000C1  80 3B 4A		    CMP BYTE PTR [EBX+0], 'J'	; porownaj znak z elementem lancucha 'DataString' 
 000000C4  74 30		    JE Got_It					; znaleziono znak 
 000000C6  80 7B 01 4A		    CMP BYTE PTR [EBX+1], 'J'	; porownaj znak z elementem lancucha 'DataString' 
 000000CA  74 2A		    JE Got_It					; znaleziono znak 
 000000CC  80 7B 02 4A		    CMP BYTE PTR [EBX+2], 'J'	; porownaj znak z elementem lancucha 'DataString' 
 000000D0  74 24		    JE Got_It					; znaleziono znak 
 000000D2  80 7B 03 4A		    CMP BYTE PTR [EBX+3], 'J'	; porownaj znak z elementem lancucha 'DataString' 
 000000D6  74 1E		    JE Got_It					; znaleziono znak 
 000000D8  80 7B 04 4A		    CMP BYTE PTR [EBX+4], 'J'	; porownaj znak z elementem lancucha 'DataString' 
 000000DC  74 18		    JE Got_It					; znaleziono znak 
 000000DE  80 7B 05 4A		    CMP BYTE PTR [EBX+5], 'J'	; porownaj znak z elementem lancucha 'DataString' 
 000000E2  74 12		    JE Got_It	
 000000E4  80 7B 06 4A		    CMP BYTE PTR [EBX+6], 'J'	; porownaj znak z elementem lancucha 'DataString' 
 000000E8  74 0C		    JE Got_It	; znaleziono znak 
 000000EA  80 7B 07 FF		    CMP BYTE PTR [EBX+7], 0FFH; porownaj znak z elementem lancucha 'DataString' 
 000000EE  74 00		    JE Not_Find	
 000000F0			Not_Find: 
 000000F0  B8 00000000		    MOV EAX,0					; zaladuj znak zapytania do DL 
 000000F5  C3			    RET							; powrot z procedury 
 000000F6			Got_It: 
 000000F6  B8 00000001		    MOV EAX,1					; wyswietl znak ne ekranie 
 000000FB  C3			    RET							; powrot z procedury 
 000000FC			FindChar_5 ENDP					; koniec FindChar_5 
				;**************************************************************************** 
				;* Procedura FindChar_6 wyszukiwania znaku 'J' w ciagu 'DataString' * 
				;* * 
				;* adresacja Disp [EBX+ESI] * 
				;* Parametry wejsciowe: * 
				;* Rej: EBX - offset zmiennej 'DataString' * 
				;* ESI - przemieszczenie * 
				;* AH - szukany znak 'J' * 
				;* Parametry wyjsciowe: * 
				;* EAX - BOOL TRUE Found, FALSE not found * 
				;* * 
				;**************************************************************************** 
 000000FC			FindChar_6 PROC NEAR 
 000000FC  BB 00000000 R	    MOV EBX, OFFSET DataString	; zaladuj offset zmiennej 'String' do rej. ESI 
 00000101  33 F6		    XOR ESI, ESI				; wyzeruj indeks lancucha 'String' w ESI 
 00000103  B4 4A		    MOV AH, 'J'					; zaladuj kod litery 'J' do rej. AH 
 00000105			Check_End: 
 00000105  80 3C 33 FF		    CMP BYTE PTR [EBX+ESI], 0FFH; czy koniec lancucha (znak specjalny FF)? 
 00000109  74 0D		    JE Not_Find					; znaleziono znak konca (wartownik) 
 0000010B  3A 24 33		    CMP AH, BYTE PTR [EBX+ESI]	; porownaj znak z elementem lancucha 'String' 
 0000010E  74 03		    JE Got_Equal    			; znaleziono znak! 
 00000110  46			    INC ESI						; inkrementuj indeks 
 00000111  EB F2		    JMP Check_End				; petla wyszukiwania 
 00000113			Got_Equal: 
 00000113  8A 14 33		    MOV DL, [EBX+ESI]			; zaladuj znaleziony znak do DL 
 00000116  EB 06		    JMP Done 
 00000118			Not_Find: 
 00000118  B8 00000000		    MOV EAX,0					; nie znaleziono znaku 
 0000011D  C3			    RET 
 0000011E			Done: 
 0000011E  B8 00000001		    MOV EAX,1					; znaleziono znak 
 00000123  C3			    RET							; powrot z procedury 
 00000124			FindChar_6 ENDP					; koniec FindChar_6 
				;****************************************************************************
 00000124			My_proc PROC NEAR 
 00000124  BB 00000000 R	    MOV EBX, OFFSET DataString	; zaladuj offset zmiennej 'DataString' do rej. EBX 
 00000129  80 3B 4A		    CMP BYTE PTR [EBX+0], 'J'	; porownaj znak z elementem lancucha 'DataString' 
 0000012C  74 30		    JE Got_It					; znaleziono znak 
 0000012E  80 7B 01 4A		    CMP BYTE PTR [EBX+1], 'J'	; porownaj znak z elementem lancucha 'DataString' 
 00000132  74 2A		    JE Got_It					; znaleziono znak 
 00000134  80 7B 02 4A		    CMP BYTE PTR [EBX+2], 'J'	; porownaj znak z elementem lancucha 'DataString' 
 00000138  74 24		    JE Got_It					; znaleziono znak 
 0000013A  80 7B 03 4A		    CMP BYTE PTR [EBX+3], 'J'	; porownaj znak z elementem lancucha 'DataString' 
 0000013E  74 1E		    JE Got_It					; znaleziono znak 
 00000140  80 7B 04 4A		    CMP BYTE PTR [EBX+4], 'J'	; porownaj znak z elementem lancucha 'DataString' 
 00000144  74 18		    JE Got_It					; znaleziono znak 
 00000146  80 7B 05 4A		    CMP BYTE PTR [EBX+5], 'J'	; porownaj znak z elementem lancucha 'DataString' 
 0000014A  74 12		    JE Got_It	
 0000014C  80 7B 06 4A		    CMP BYTE PTR [EBX+6], 'J'	; porownaj znak z elementem lancucha 'DataString' 
 00000150  74 0C		    JE Got_It	; znaleziono znak 
 00000152  80 7B 07 4A		    CMP BYTE PTR [EBX+7], 'J'	; porownaj znak z elementem lancucha 'DataString' 
 00000156  74 00		    JE Not_Find	
 00000158			Not_Find: 
 00000158  B8 00000000		    MOV EAX,0					; zaladuj znak zapytania do DL 
 0000015D  C3			    RET							; powrot z procedury 
 0000015E			Got_It: 
 0000015E  B8 00000001		    MOV EAX,1					; wyswietl znak ne ekranie 
 00000163  C3			    RET							; powrot z procedury 
 00000164			My_proc ENDP					; koniec FindChar_5 
				;****************************************************************************
				;* Procedura ReadTime_1 pomiaru czasu wykonania procedury FindChar_1 * 
				;* * 
				;* do pomiaru wykorzystywany jest licznik taktów zegara procesora * 
				;* Parametry wejsciowe: * 
				;* Parametry wyjsciowe: * 
				;* EAX - czas w taktach zegara * 
				;* * 
				;**************************************************************************** 
				.586
 00000164			ReadTime_1 PROC NEAR
				    ;CPUID						; celowo brak komentarza

 00000164  0F 31		    RDTSC						; odczyt licznika taktów
 00000166  8B C8		    MOV ECX,EAX

 00000168  E8 FFFFFF8F		    CALL FindChar_6				; wywo³anie badanej funkcji

 0000016D  0F 31		    RDTSC
 0000016F  2B C1		    SUB EAX,ECX

 00000171  C3			    RET
 00000172			ReadTime_1 ENDP 
				;**************************************************************************** 
 00000172			ReadTime_3 PROC AppString: DWORD
				    ;CPUID						; celowo brak komentarza

 00000175  0F 31		    RDTSC						; odczyt licznika taktów
 00000177  8B C8		    MOV ECX,EAX

 00000179  FF 75 08		    PUSH AppString
 0000017C  E8 FFFFFEDD		    CALL FindChar_3				; wywo³anie badanej funkcji

 00000181  0F 31		    RDTSC
 00000183  2B C1		    SUB EAX,ECX

				    RET
 00000189			ReadTime_3 ENDP 
				;**************************************************************************** 
				END DllEntry 
Microsoft (R) Macro Assembler Version 14.29.30037.0	    06/25/21 08:24:36
mydll.asm						     Symbols 2 - 1




Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

FLAT . . . . . . . . . . . . . .	GROUP
_DATA  . . . . . . . . . . . . .	32 Bit	 00000008 DWord	  Public  'DATA'	
_TEXT  . . . . . . . . . . . . .	32 Bit	 00000189 DWord	  Public  'CODE'	


Procedures, parameters, and locals:

                N a m e                 Type     Value    Attr

DllEntry . . . . . . . . . . . .	P Near	 00000000 _TEXT	Length= 0000000C Public STDCALL
FindChar_1 . . . . . . . . . . .	P Near	 0000000C _TEXT	Length= 00000025 Public STDCALL
FindChar_2 . . . . . . . . . . .	P Near	 00000039 _TEXT	Length= 00000025 Public STDCALL
FindChar_3 . . . . . . . . . . .	P Near	 0000005E _TEXT	Length= 0000002C Public STDCALL
FindChar_4 . . . . . . . . . . .	P Near	 0000008A _TEXT	Length= 00000032 Public STDCALL
FindChar_5 . . . . . . . . . . .	P Near	 000000BC _TEXT	Length= 00000040 Public STDCALL
FindChar_6 . . . . . . . . . . .	P Near	 000000FC _TEXT	Length= 00000028 Public STDCALL
My_proc  . . . . . . . . . . . .	P Near	 00000124 _TEXT	Length= 00000040 Public STDCALL
ReadTime_1 . . . . . . . . . . .	P Near	 00000164 _TEXT	Length= 0000000E Public STDCALL
ReadTime_3 . . . . . . . . . . .	P Near	 00000172 _TEXT	Length= 00000017 Public STDCALL


Symbols:

                N a m e                 Type     Value    Attr

@CodeSize  . . . . . . . . . . .	Number	 00000000h   
@DataSize  . . . . . . . . . . .	Number	 00000000h   
@Interface . . . . . . . . . . .	Number	 00000003h   
@Model . . . . . . . . . . . . .	Number	 00000007h   
@code  . . . . . . . . . . . . .	Text   	 _TEXT
@data  . . . . . . . . . . . . .	Text   	 FLAT
@fardata?  . . . . . . . . . . .	Text   	 FLAT
@fardata . . . . . . . . . . . .	Text   	 FLAT
@stack . . . . . . . . . . . . .	Text   	 FLAT

	   3 Warnings
	   0 Errors
